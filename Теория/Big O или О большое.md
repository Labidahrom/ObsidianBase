<h1>Big O или О большое</h1>
<b>Big O или Big O натация</b> - определяет сложность алгоритма. Сложность определяется в количестве операций, и количество операций всегда выражается в n. Например для бинарного поиска в отсортированном массиве сложность будет О(log2n) - логирифм числа n по основанию 2. 
Если мы просто перебираем все элементы списка по порядку, то сложность равна просто O(n), где n - это просто количество элементов в массиве. А когда например мы находим элемент в массиве по заранее известному нам индексу, то сложность такой операции равна O(1), потому что это требует всего 1 операции

<h2>O(1)</h2>
Описывает сложность порядка "1". Еще называется <b>постоянное время</b>. То есть, когда для выполнения задачи нам требуется всего 1 операция. Пример: когда нам надо найти в массиве элемент по заранее известному индексу. Что еще важно, такие алгоритмы выполняются за постоянное (константное время) так как заранее известно количество операций - 1, и оно во всех случаях будет ему равняться

<h2>O(n)</h2>
Описывает сложность порядка "n", или например <b>"линейная сложность"</b> или линейный алгоритм. Описывает ситуации когда нам надо перебрать весь массив, и в этом случае количество операций равно длине массива

<h2>O(log2n)</h2>
Описывает сложность алгоритма бинарного поиска, так как там количество операциий равно логарифму длины массива по основанию 2

<h2>O(n^2)</h2>
Описывает сложность порядка <b>n в квадрате</b>. Это те случаи когда мы в цикле используем еще один вложенный цикл. Например проверяем массив длиной в 4 элемента циклом, со вложенным циклом. Получается 4^2 или 16 операций, так как мы 4 раза запустили цикл с 4 итерациями

^dd4b44

<h2>O(n * log(n))</h2>
Это ситуация, когда мы внутри линейного алгоритма запускаем бинарный поиск. <b>Быстрая сортировка</b> в среднем случае может работь с такой сложностью, но не всегда!

<h2>O(n!)</h2>
Примером является <b>задача о коммивояжоре</b>, где есть 5 городов, и нужно сравнить путь по длине комбинируя города во всех возможных комбинациях