<h1>SOLID</h1>
**SOLID** - это набор принципов проектирования объектно-ориентированного программирования, которые помогают создавать гибкие, расширяемые и поддерживаемые системы. Там такие принципы: 
1. **Принцип единственной ответственности (Single Responsibility Principle, SRP)** : Каждый класс или модуль должен иметь только одну причину для изменения. Он должен быть ответственным только за одну часть функциональности или один аспект системы. Если класс или модуль выполняет несколько разных задач, следует разделить его на более мелкие классы или модули. 

2. **Принцип открытости/закрытости (Open/Closed Principle, OCP)**: Программные сущности (классы, модули, функции) должны быть открытыми для расширения, но закрытыми для модификации. Вместо изменения существующего кода, следует использовать наследование, интерфейсы или паттерны проектирования, чтобы добавить новую функциональность или изменить поведение сущности. 

3. **Принцип подстановки Лисков (Liskov Substitution Principle, LSP)**: Объекты одного класса должны быть взаимозаменяемы с объектами любого из его подклассов без нарушения корректности программы. Это означает, что подклассы не должны изменять предусловия, постусловия и инварианты базового класса. Нарушение принципа LSP может привести к непредсказуемому поведению программы. 

4. **Принцип разделения интерфейса (Interface Segregation Principle, ISP)**: Клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы следует разделять на более мелкие, специфичные для клиентов, чтобы избежать вынужденной зависимости от ненужных методов. Это позволяет уменьшить связность и сделать систему более гибкой.

5. **Принцип инверсии зависимостей** или **Dependency Inversion Principle (DIP)**: DIP гласит:
- [ ] Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций
- [ ] Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций
Если упросить то что написано выше, то Это значит, что мы должны стараться делать наши модули независимыми друг от друга. Пример класса который нарушает DIP:
```
class MySQLDatabase:
    def save(self, data):
        print(f"Saving {data} to MySQL database")

class User:
    def __init__(self):
        self.database = MySQLDatabase()

    def save_user(self, data):
        self.database.save(data)

```
В примере выше мы сразу создаем внутри класса зависимость от другого класса, что неправильно. Пример правильного кода ниже (мы в нем передаем нужный класс в виде аргумента, а не определяем его заранее в классе). И как раз **абстракцией** в этом случае является аргумент **data** в class MySQLDatabase:
```
class Database:
    def save(self, data):
        pass

class MySQLDatabase:
    def save(self, data):
        print(f"Saving {data} to MySQL database")

class User:
    def __init__(self, database):
        self.database = database

    def save_user(self, data):
        self.database.save(data)

```
