<h2>Граф</h2>
Моделирует набор связей между элементами. Пример графа:
![[графы.jpg]]
Связи между элементами называются ребра, элементы (круглешки) - это ребра

<h2>FIFO - First In First Out</h2>
First In First Out - категория структур данных,  первый защел, первый вышел. Это принцип очереди. По такому принципу работает очередь

<h2>LIFO - Last In First Out</h2>
Last In First Out - категория структур данных,  последний прищел, первым вышел. Это например принцип стека

<h2>Массив (из базового типа данных в информатике)</h2>
В массиве элементы хранятся в соседних ячейках памяти, и позволяют сразу обращатся к ним по порядковому номеру. За счет этого массив удобно использовать как неизменяемую сущность, например для чтения. Так как если в массив нужно добавить элемент, в памяти нужно искать количество свободных ячеек которые равно количеству элементов массива

<h2>Связанный писок (из базового типа данных в информатике)</h2>
В связанном списке элементы могут находится НЕ в соседних ячейках памяти. Связанность достигается тем, что каждый элемент хринит ссылку на следующий за ним элемент. Поэтому, если например нужно сослаться на 7 элемент в списке, нужно перебрать 6 предыдущих, иначе мы не найдем ссылки на 7. При этом, элементы связанного списка могут храниться в разрозненых ячейках памяти (не стоящих рядом). Это дает то, что если мы добавляем в список элемент, нам не нужно искать область в памяти, достаточную для вмещения в себя нашего нового, увеличенного на 1 элемент списка, а достаточно лишь добавить 1 ячейку памяти (что конечно быстрее и эффективнее чем в случае с массивом). Поэтому, для всех операций которые предполагают изменение списка (удалить элемент, вставить и тд), связанный список эфеективнее чем массив. А вот для операций чтения эффективнее массив

<h2>Хэш - таблица</h2>
Может еще называться асициативный массив, словарь (в питоне так называется подбный тип данных), отображение. Хэш таблица это когда каждому элементу соотвествует какой либо ключ. Поскольку ключи отсортированы и хранятся в массиве, доступ к элементу по ключу мгновенный. В питоне аналогом хэш таблиц считается словарь

<h2>Индекс</h2>
Порядковый номер элемента в списке или в массиве. Например, в [f, d] индекс f равен 0

<h2>Множества и словари всегда работают быстрее списков если нужно проверить что на вхождение в них</h2>
Потому что там все отсортировано и можно применить алгоритмы быстрого поиска

<h2>Коллизия</h2>
Это ситуация когда 2 ключам назначается <b>ОДИН и ТОТ ЖЕ элемент массива</b>. Для хэш таблиц когда мы не можем добавить какое то значение, потому что его место о отсортированном списке уже занято. Например, у нас есть элемент авокадо, и есть элемент банан, между ними нет свободной ячейке. и тут нам надо добавить апельсин. Получается, апельсин надо поместить после авокадо, но как это сделать, если между авокадо и апельсином нет места? 
<b>Как справляться с коллизией?</b> Можно в ячейку куда не влазиет элемент, вместо изначального элемента, поместить связанный список из того элемента который был, и того, который надо добавить

